JPA에서 가장 중요한 2가지
1. 객체와 관계형 데이터베이스 매핑하기
2. 영속성 컨텍스트

엔티티 매니저 팩토리
: 고객의 요청이 올 때마다 엔티티 매니저를 생성함

엔티티 매니저
: 데이터 커넥션을 사용해서 DB를 사용함
: 엔티티 매니저를 통해 영속성 컨텍스트에 접근함

영속성 컨텍스트
: 엔티티를 영구 저장하는 환경 (논리적인 개념)
ex) em.persist([엔티티]);
-> persist() 메서드는 DB에 저장하는 것이 아니라 엔티티를 영속성 컨텍스트 라는 곳에 저장하는 것임

엔티티의 생명주기
1. 비영속
: 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 (= 객체를 생성만 한 상태)
2.영속
: 영속성 컨텍스트에 관리되는 상태 (= 엔티티 매니저의 persist()를 통해 영속성 컨텍스트에 저장한 상태)
3. 준영속
: 영속성 컨텍스트에 저장되었다가 분리된 상태 (= 엔티티 매니저의 detach()를 통해 영속성 컨테이너에서 지움)
4. 삭제
: 삭제된 상태 (= 엔티티 매니저의 remove()를 통해 객체를 삭제함)

영속성 컨텍스트의 이점
1. 1차 캐시
: @Id와 Entity 상태로 영속성 컨텍스트에 저장됨
- 조회 시, DB를 거치기 전에 먼저 1차 캐시인 영속성 컨텍스트부터 찾아보기 때문에 빠름
- 만약 1차 캐시에 없어서 DB를 통해 조회했을 경우에는 영속성 컨텍스트에 저장함 (다음부터는 1차 캐시로 가져올 수 있음)
- 하지만, 영속성 컨텍스트는 엔티티 매니저마다 따로 관리되기 때문에 성능 면에서 크게 기대하기는 어려움
2. 동일성 보장
: 같은 트랜잭션 안에서 동일한 PK를 가진 엔티티는 동일성을 보장한다.
3. 트랜잭션을 지원하는 쓰기 지연
: 쓰기 지연 SQL 저장소에 저장했다가, 트랜잭션을 커밋하는 순간에 한꺼번에 DB에 쿼리를 보냄
4. 변경 감지 (Dirty Checking)
: 커밋이 일어나면, 엔티티와 스냅샷을 비교함 -> 엔티티가 바뀌면 update 쿼리를 날림
5. 지연 로딩

플러시
: 영속성 컨텍스트의 변경 내용을 DB에 반영함 (동기화 작업)
- 영속성 컨텍스트의 내용을 비우는것이 아님!
- 트랜잭션 커밋 직전에만 동기화 하면 됨

영속성 컨텍스트를 플러시하는 방법
1. em.flush() (직접 호출)
2. 트랜잭션 커밋 (자동 호출)
3. JPQL 쿼리 실행 (자동 호출)
: JPQL 쿼리 실행 시에, 영속성 컨텍스트에만 저장된 엔티티도 쿼리 조회 대상이 되어야 하기 때문에, 자동으로 플러시(DB에 반영하는 작업)가 호출됨

플러시 모드 옵션 (em.setFlushMode([모드]))
1. FlushModeType.AUTO (커밋 또는 쿼리 실행시 플러시)
2. FlushModeType.COMMIT (커밋 시에만 플러시)

준영속 상태
: 1차 캐시에서 내려간 상태로, JPA 가 관리하지 않음.

준영속 상태로 만드는 방법
1. em.detach([엔티티])
: 특정 엔티티만 준영속 상태로 전환
2. em.clear()
: 영속성 컨텍스트를 초기화
3. em.close()
: 영속성 컨텍스트를 종료
