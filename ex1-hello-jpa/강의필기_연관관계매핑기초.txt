예제 시나리오
1. 회원과 팀이 있다.
2. 회원은 하나의 팀에만 소속될 수 있다.
3. 회원과 팀은 다대일 관계다.

* 연관관계가 없는 객체 -> 객체를 테이블에 맞추어 모델링
- 회원:팀이 N:1 관계이므로 회원 테이블에 팀의 PK를 외래키로 관계 설정
테이블 연관관계
MEMBER
MEMBER_ID(PK), TEAM_ID(FK), USERNAME
TEAM
TEAM_ID(PK), NAME

객체 연관관계
Member
id, teamID, username
Team
id, name

연관관계 없는 객체 문제점
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
- 테이블은 외래 키로 조인을 사용해서 테이블을 찾고, 객체는 참조를 사용해서 연관된 객체를 찾는다. (이렇듯 테이블과 객체 사이에는 큰 간격이 존재)

* 단방향 연관관계
- 회원 테이블에 '팀의 PK' 대신 '팀 객체' 로 관계 설정
객체 연관관계
Member
id, team, username  //이때 team에는 다대일 연관관계를 나타내는 @ManyToOne 어노테이션과 DB에서 사용할 수 있도록 FK를 설정하기 위한 @JoinColumn 어노테이션을 사용해야 함
Team
id, name

- 객체는 최대한 단방향으로 설정하는 것이 좋음(양방향이면 신경쓸게 많음)

* 양방향 연관관계
- 테이블 외래키는 한번 외래키를 설정하면 양쪽 테이블에서 모두 조인이 가능하지만 객체는 한 방향으로만 가능하기 때문에 역으로는 참조하기 어렵다.
- 따라서 양쪽 객체가 서로의 객체를 가지고 있어야 양방향 참조가 가능함
- FK(객체)를 가지지 않은 반대쪽 테이블에서는 일대다 연관관계를 나타내는 @OneToMany 어노테이션과 상대쪽에서 FK(객체)를 무슨 필드명으로 쓰고 있는지 매핑하기 위해 mappedBy 속성을 사용해야 함

연관관계의 주인과 mappedBy
- 객체와 테이블이 관계를 맺는 차이를 먼저 알아야 한다.
- 객체는 연관관계가 2개이다. (회원->팀(단방향), 팀->회원(단방향))
  = 객체를 양방향으로 참조하려면 단방향 연관관계 2개를 만들어야 한다. (A->B(a.get(B)), B->A(b.get(A)))
- 반면 테이블은 연관관계가 1개이다. (회원<->팀(양방향))
  = 외래키 하나로 양방향 연관관계가지며 양쪽으로 조인할 수 있다.

그렇다면 외래키 역할을 하는 필드 값이 바뀐다면 어느쪽에서 수정을 해야 할까?
- 둘 중 하나로 외래 키를 관리해야 한다. -> 연관관계 주인

양방향 매칭 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정한다.
- 연관관계의 주인만이 외래 키를 관리(등록, 수정)한다.
- 주인이 아닌쪽은 읽기만 가능하다. (수정해봤자 DB에 갱신되지 않음 -> 주의할 것!!)
- 주인은 mappedBy 속성을 사용하면 안된다. (mappedBy가 누군가에 의해 매핑되었다는 소리니까)
- 외래키가 있는 곳을 주인으로! (테이블에서 외래키가 있는 쪽은 일대다 관계일 때 보통 ManyToOne) -> 비즈니스 로직을 기준으로 주인을 선택하면 안됨!!

그러나! 값을 변경할 때에는 연관관계 주인 뿐만 아니라 역방향에도 설정해주는 것이 바람직하다.
- 연관관계 주인만 값을 변경할 경우, flush를 즉시 하지 않으면 해당 변경분이 1차 캐시에 머무르게 됨-> 역방향에 있는 외래키 필드 값은 갱신되지 않음
- 또한 객체지향적인 측면에서도 서로 다른 값을 가지는 것은 바람직하지 않음

하지만, 외래키임을 알고, 양쪽에 값을 설정하는 일은 번거롭고 깜빡할 수 있다.
- 연관관계 편의 메소드를 생성하자! (= ManyToOne에서 외래키 필드 값을 설정하는 부분에 OneToMany 쪽의 값도 변경하는 코드 추가 & 기능이 바뀌었으니 메소드 이름 변경(=changeXXX))
  ex) this.getTeam().getMembers().add(this);
- 또는 OneToMany에서 이 기능을 하는 addXXX() 메소드를 추가하는 것도 가능함
- changeXXX 또는 addXXX 둘 중 편하다고 생각하는 하나만 만드는 것이 좋음 (헷갈리지 않게)
  ex) changeTeam() 또는 addMember() 둘 중 하나

양방향 관계 매핑시 주의할 점
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 (+ 연관관계 편의 메소드를 설정하자)
- 양방향 매핑시 무한 루프를 조심하자 (toString(), lombok, JSON 생성 라이브러리)
  ex) team은 member 정보를 부르고 다시 member는 team의 정보를 부르고,,
- 컨트롤러에서 엔티티를 절대 반환하지 말자! -> 무한 루프의 문제점, 엔티티를 변경하는 순간 API의 스펙이 바뀌어 버림
  단순히 값만 있는 DTO로 변환해서 반환하자!

최종 정리
- 처음에는 무조건 단방향 매핑으로 설계하자 (양방향 매핑은 반대방향으로의 조회 기능을 추가하기 위한 것)
- JPQL에서 역방향으로 탐색할 일이 많기 때문에 이럴 때 추가
- 단방향에서 양방향으로 바꾸는 것은 테이블에 영향을 주지 않기 때문에 그때 추가해도 됨 -> 먼저 단방향 매핑을 짜는 것부터 잘하자!












